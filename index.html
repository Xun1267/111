<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>场独立-场依存认知风格对视觉错觉调节作用实验</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #ffffff;
            color: #333333;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        #container {
            text-align: center;
            width: 100%;
            max-width: 800px;
            position: relative;
            z-index: 1;
        }

        canvas {
            background-color: #ffffff;
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999;
        }

        .screen {
            display: none;
            padding: 20px;
        }

        .screen.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        h1 { margin-bottom: 20px; font-weight: 300; color: #000; }
        p { line-height: 1.6; font-size: 1.1rem; margin-bottom: 20px; }
        
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        button:hover { background-color: #45a049; }

        input, select {
            padding: 10px;
            font-size: 16px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background: #fff;
            color: #333;
            margin: 5px;
        }

        .calibration-box {
            width: 300px; 
            height: 180px; 
            background-color: #333;
            border-radius: 10px;
            margin: 20px auto;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        #calibration-slider {
            width: 50%;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
</head>
<body>

<div id="container">

    <!-- 1. 欢迎与信息录入界面 -->
    <div id="screen-welcome" class="screen active">
        <h1>视错觉实验</h1>
        <p>欢迎参与本研究。本实验旨在探究认知风格对视觉知觉的影响。</p>
        <div style="margin-bottom: 20px; text-align: left; display: inline-block;">
            <label>被试编号 (ID):</label><br>
            <input type="text" id="subject-id" value="001"><br><br>
        </div>
        <br>
        <button onclick="experiment.goToCalibration()">下一步</button>
    </div>

    <!-- 2. 屏幕校准界面 -->
    <div id="screen-calibration" class="screen">
        <h1>屏幕校准</h1>
        <p>为了确保实验刺激的大小在不同屏幕上一致，请拿出您的<b>学生证</b>或<b>身份证</b>。</p>
        <p>拖动下方的滑块，调整深色卡片的宽，使其宽度与真实卡片相符。</p>
        
        <div id="card-rect" class="calibration-box">银行卡 / 身份证</div>
        <input type="range" id="calibration-slider" min="100" max="800" value="300" oninput="experiment.updateCalibration(this.value)">
        <br><br>
        <button onclick="experiment.initExperimentAndStart()">完成校准，开始实验</button>
    </div>

    <!-- 3. 缪勒-莱耶错觉 指导语 -->
    <div id="screen-mli-intro" class="screen">
        <h1>任务：缪勒-莱耶错觉</h1>
        <p>在接下来的实验中，屏幕左右两侧将同时出现两条水平线段。</p>
        <p>请您判断：<b>哪一侧的水平线段看起来更长？</b></p>
        <ul style="text-align: left; display: inline-block;">
            <li>如果<b>左侧</b>线段更长，请按键盘上的 <b>“F”</b> 键。</li>
            <li>如果<b>右侧</b>线段更长，请按键盘上的 <b>“J”</b> 键。</li>
        </ul>
        <p>为了让您熟悉按键操作，我们将先进行 <b>5次练习</b>。</p>
        <button onclick="experiment.startCurrentTaskPractice()">开始练习</button>
    </div>

    <!-- 4. 庞佐错觉 指导语 -->
    <div id="screen-ponzo-intro" class="screen">
        <h1>任务：庞佐错觉</h1>
        <p>任务已切换。现在屏幕上将出现两条会聚的线（背景），中间有上下两条水平线段。</p>
        <p>请您判断：<b>哪一条水平线段看起来更长？</b></p>
        <ul style="text-align: left; display: inline-block;">
            <li>如果<b>上方</b>线段更长，请按键盘上的 <b>“F”</b> 键。</li>
            <li>如果<b>下方</b>线段更长，请按键盘上的 <b>“J”</b> 键。</li>
        </ul>
        <p>注意：请忽略背景线条，仅关注水平线段的长度。</p>
        <p>为了让您熟悉按键操作，我们将先进行 <b>5次练习</b>。</p>
        <button onclick="experiment.startCurrentTaskPractice()">开始练习</button>
    </div>

    <!-- 5. 练习结束提示 -->
    <div id="screen-practice-end" class="screen">
        <h1>练习结束</h1>
        <p>您已完成练习阶段。</p>
        <p>接下来将进入<b>正式实验</b>。</p>
        <p>请保持专注，在保证准确的前提下尽快按键。</p>
        <button onclick="experiment.startCurrentTaskFormal()">开始正式实验</button>
    </div>

    <!-- 6. 休息界面 -->
    <div id="screen-break" class="screen">
        <h1>休息时间</h1>
        <p>您已完成了一组实验。</p>
        <p>请闭眼休息片刻，缓解视觉疲劳。</p>
        <div id="break-timer" style="font-size: 2rem; font-weight: bold; color: #4CAF50;">10</div>
        <p>秒后可继续。</p>
        <button id="btn-resume" onclick="experiment.resumeBlock()" disabled>继续实验</button>
    </div>

    <!-- 7. 结束与下载 -->
    <div id="screen-end" class="screen">
        <h1>实验结束</h1>
        <p>感谢您的参与！</p>
        <p>数据已准备就绪。</p>
        <button onclick="experiment.downloadData()">下载数据 (CSV)</button>
    </div>

</div>

<canvas id="experiment-canvas"></canvas>
<!-- 移除了 trial-counter div -->

<script>
class Experiment {
    constructor() {
        this.subjectId = '';
        this.pxPerMm = 3.5; 
        
        // 任务流控制
        this.taskOrder = []; // 存储任务顺序 ['MLI', 'Ponzo'] 或 ['Ponzo', 'MLI']
        this.currentTaskIdx = 0; // 当前第几个任务
        this.isPractice = false; // 当前是否为练习阶段
        
        this.trials = [];
        this.currentTrialIndex = 0;
        this.isResting = false;
        this.justRested = false;
        
        this.results = [];

        this.canvas = document.getElementById('experiment-canvas');
        this.ctx = this.canvas.getContext('2d');
        
        document.addEventListener('keydown', (e) => this.handleInput(e));
        
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
    }

    resizeCanvas() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        // 只有在非休息且有试次时才重绘
        if(this.trials.length > 0 && !this.isResting && this.canvas.style.display !== 'none') {
            this.drawStimulus();
        }
    }

    // --- 界面导航 ---

    showScreen(screenId) {
        document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
        
        if (screenId) {
            const screen = document.getElementById(screenId);
            if (screen) {
                screen.classList.add('active');
            }
        }
        
        // 隐藏画布
        if (screenId) {
            this.canvas.style.display = 'none';
        }
    }

    goToCalibration() {
        this.subjectId = document.getElementById('subject-id').value;
        if(!this.subjectId) { alert("请输入被试编号"); return; }
        this.showScreen('screen-calibration');
    }

    updateCalibration(val) {
        const div = document.getElementById('card-rect');
        div.style.width = val + 'px';
        this.pxPerMm = val / 85.6; 
    }

    // --- 实验初始化与流程控制 ---

    initExperimentAndStart() {
        // 1. 随机化任务顺序
        if (Math.random() > 0.5) {
            this.taskOrder = ['MLI', 'Ponzo'];
        } else {
            this.taskOrder = ['Ponzo', 'MLI'];
        }
        console.log("Task Order:", this.taskOrder);

        // 2. 尝试全屏
        if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen().catch(err => console.log("Fullscreen skipped"));
        }

        // 3. 进入第一个任务的介绍页
        this.currentTaskIdx = 0;
        this.showCurrentTaskIntro();
    }

    showCurrentTaskIntro() {
        const taskType = this.taskOrder[this.currentTaskIdx];
        if (taskType === 'MLI') {
            this.showScreen('screen-mli-intro');
        } else {
            this.showScreen('screen-ponzo-intro');
        }
    }

    startCurrentTaskPractice() {
        const taskType = this.taskOrder[this.currentTaskIdx];
        this.isPractice = true;
        
        // 生成练习试次 (固定5次)
        this.trials = this.generateTrials(taskType, true);
        this.currentTrialIndex = 0;
        this.startBlock();
    }

    startCurrentTaskFormal() {
        const taskType = this.taskOrder[this.currentTaskIdx];
        this.isPractice = false;
        
        // 生成正式试次
        this.trials = this.generateTrials(taskType, false);
        this.currentTrialIndex = 0;
        this.startBlock();
    }

    // --- 试次生成 ---

    generateTrials(taskType, isPracticeMode) {
        let trials = [];
        const ratios = [0.85, 0.90, 0.95, 1.00, 1.05, 1.10, 1.15]; 

        if (isPracticeMode) {
            // 练习模式：随机生成5个试次
            for (let i = 0; i < 5; i++) {
                // 随机选择角度和比率
                const randAngle = taskType === 'MLI' ? [30, 60, 90][Math.floor(Math.random()*3)] : [10, 20, 30][Math.floor(Math.random()*3)];
                const randRatio = ratios[Math.floor(Math.random() * ratios.length)];
                
                trials.push(this.createTrialObject(taskType, randAngle, randRatio));
            }
            return trials;
        }

        // 正式模式：完全析因设计
        // 修改：设置为 12 次重复，共 3 * 7 * 12 = 252 次
        const repetitions = 12; 
        
        if (taskType === 'MLI') {
            const angles = [30, 60, 90];
            for (let ang of angles) {
                for (let r of ratios) {
                    for (let i = 0; i < repetitions; i++) {
                        trials.push(this.createTrialObject('MLI', ang, r));
                    }
                }
            }
        } else if (taskType === 'Ponzo') {
            const angles = [10, 20, 30]; 
            for (let ang of angles) {
                for (let r of ratios) {
                    for (let i = 0; i < repetitions; i++) {
                        trials.push(this.createTrialObject('Ponzo', ang, r));
                    }
                }
            }
        }

        // 随机化顺序
        for (let i = trials.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [trials[i], trials[j]] = [trials[j], trials[i]];
        }
        
        return trials;
    }

    createTrialObject(type, angle, ratio) {
        const standardLen = (type === 'MLI') ? 300 : 200;
        if (type === 'MLI') {
            return {
                type: 'MLI',
                angle: angle,
                standardLen: standardLen,
                compLen: standardLen * ratio,
                standardPos: Math.random() > 0.5 ? 'left' : 'right', 
            };
        } else {
            return {
                type: 'Ponzo',
                bgAngle: angle,
                topLen: standardLen,
                bottomLen: standardLen * ratio,
                targetPos: 'top-bottom', 
            };
        }
    }

    startBlock() {
        this.justRested = true; // 刚开始不需要休息
        document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
        this.canvas.style.display = 'block';
        // 移除了计数器显示代码
        this.runTrial();
    }

    runTrial() {
        // 检查本组试次是否完成
        if (this.currentTrialIndex >= this.trials.length) {
            this.handleBlockEnd();
            return;
        }

        // 休息逻辑：仅在正式实验中，每 84 次休息一次 (252 / 3 = 84)
        if (!this.isPractice && this.currentTrialIndex > 0 && this.currentTrialIndex % 84 === 0 && !this.justRested) {
            this.startBreak();
            this.justRested = true;
            return;
        }
        this.justRested = false;

        const trial = this.trials[this.currentTrialIndex];
        
        // 1. 注视点
        this.drawFixation();
        this.inputAllowed = false;
        
        setTimeout(() => {
            // 2. 刺激呈现
            this.drawStimulus(trial);
            this.startTime = performance.now();
            this.inputAllowed = true;
            
            // 移除了更新 trial-counter 的逻辑
        }, 500);
    }

    handleBlockEnd() {
        if (this.isPractice) {
            // 练习结束 -> 显示过渡页
            this.showScreen('screen-practice-end');
        } else {
            // 正式实验结束 -> 检查是否还有下一个任务
            this.currentTaskIdx++;
            if (this.currentTaskIdx < this.taskOrder.length) {
                // 还有任务 -> 进入下一个任务介绍
                this.showCurrentTaskIntro();
            } else {
                // 没有任务了 -> 实验结束
                this.showScreen('screen-end');
            }
        }
    }

    startBreak() {
        this.isResting = true;
        this.showScreen('screen-break');
        
        let seconds = 10; 
        const timerEl = document.getElementById('break-timer');
        const btn = document.getElementById('btn-resume');
        
        timerEl.innerText = seconds;
        btn.disabled = true;
        btn.style.backgroundColor = '#ccc';
        btn.innerText = `休息中 (${seconds})`;
        
        this.breakInterval = setInterval(() => {
            seconds--;
            timerEl.innerText = seconds;
            btn.innerText = `休息中 (${seconds})`;
            if (seconds <= 0) {
                clearInterval(this.breakInterval);
                btn.disabled = false;
                btn.style.backgroundColor = '#4CAF50';
                btn.innerText = "继续实验";
            }
        }, 1000);
    }

    resumeBlock() {
        this.isResting = false;
        this.showScreen(''); 
        this.canvas.style.display = 'block'; 
        // 移除了计数器显示代码
        this.runTrial();
    }

    // --- 绘图函数 ---

    drawFixation() {
        const ctx = this.ctx;
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx - 10, cy);
        ctx.lineTo(cx + 10, cy);
        ctx.moveTo(cx, cy - 10);
        ctx.lineTo(cx, cy + 10);
        ctx.stroke();
    }

    drawStimulus(trial = this.trials[this.currentTrialIndex]) {
        const ctx = this.ctx;
        const w = this.canvas.width;
        const h = this.canvas.height;
        
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, w, h);
        
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        if (trial.type === 'MLI') {
            const y = h / 2;
            const offset = w / 4; 
            
            const leftX = w/2 - offset;
            const rightX = w/2 + offset;

            let stimLeft, stimRight;
            
            const standardObj = { len: trial.standardLen, angle: 45, finType: 'out' };
            const compObj = { len: trial.compLen, angle: trial.angle, finType: 'in' };

            if (trial.standardPos === 'left') {
                stimLeft = standardObj;
                stimRight = compObj;
            } else {
                stimLeft = compObj;
                stimRight = standardObj;
            }

            this.drawArrowLine(ctx, leftX, y, stimLeft.len, stimLeft.angle, stimLeft.finType);
            this.drawArrowLine(ctx, rightX, y, stimRight.len, stimRight.angle, stimRight.finType);

        } else if (trial.type === 'Ponzo') {
            const cx = w / 2;
            const cy = h / 2;
            
            const frameHeight = 500; 
            const topY = cy - frameHeight / 2; 
            const bottomY = cy + frameHeight / 2; 
            
            const halfAngleRad = (trial.bgAngle / 2) * (Math.PI / 180);
            const bottomWidth = 400;
            const halfBottomW = bottomWidth / 2;
            const narrowAmt = frameHeight * Math.tan(halfAngleRad);
            const halfTopW = halfBottomW - narrowAmt;
            
            ctx.beginPath();
            ctx.strokeStyle = '#666666'; 
            
            ctx.moveTo(cx - halfBottomW, bottomY);
            ctx.lineTo(cx - halfTopW, topY);
            
            ctx.moveTo(cx + halfBottomW, bottomY);
            ctx.lineTo(cx + halfTopW, topY);
            ctx.stroke();

            ctx.strokeStyle = '#000000'; 
            
            const standardY = cy - 100;
            this.drawHLine(ctx, cx, standardY, trial.topLen);

            const comparisonY = cy + 100;
            this.drawHLine(ctx, cx, comparisonY, trial.bottomLen);
        }
    }

    drawArrowLine(ctx, cx, cy, len, angleDeg, type) {
        const halfLen = len / 2;
        const rad = (angleDeg * Math.PI) / 180;
        const finLen = 40; 

        ctx.beginPath();
        ctx.moveTo(cx - halfLen, cy);
        ctx.lineTo(cx + halfLen, cy);
        ctx.stroke();

        this.drawFin(ctx, cx - halfLen, cy, rad, finLen, type === 'out' ? 'left-out' : 'left-in');
        this.drawFin(ctx, cx + halfLen, cy, rad, finLen, type === 'out' ? 'right-out' : 'right-in');
    }

    drawFin(ctx, x, y, rad, len, mode) {
        ctx.beginPath();
        const cos = Math.cos(rad) * len;
        const sin = Math.sin(rad) * len;
        
        // 简化代码逻辑
        if (mode.includes('left')) {
            // left end of line
             if (mode === 'left-out') { // <
                ctx.moveTo(x, y); ctx.lineTo(x - cos, y - sin);
                ctx.moveTo(x, y); ctx.lineTo(x - cos, y + sin);
             } else { // >
                ctx.moveTo(x, y); ctx.lineTo(x + cos, y - sin);
                ctx.moveTo(x, y); ctx.lineTo(x + cos, y + sin);
             }
        } else {
            // right end of line
            if (mode === 'right-out') { // >
                ctx.moveTo(x, y); ctx.lineTo(x + cos, y - sin);
                ctx.moveTo(x, y); ctx.lineTo(x + cos, y + sin);
            } else { // <
                ctx.moveTo(x, y); ctx.lineTo(x - cos, y - sin);
                ctx.moveTo(x, y); ctx.lineTo(x - cos, y + sin);
            }
        }
        ctx.stroke();
    }

    drawHLine(ctx, cx, y, len) {
        ctx.beginPath();
        ctx.moveTo(cx - len/2, y);
        ctx.lineTo(cx + len/2, y);
        ctx.stroke();
    }

    handleInput(e) {
        if (!this.inputAllowed) return;

        let response = null;
        if (e.key.toLowerCase() === 'f') response = 'F';
        if (e.key.toLowerCase() === 'j') response = 'J';

        if (response) {
            this.recordData(response);
            this.nextTrial();
        }
    }

    recordData(response) {
        // 如果是练习阶段，不记录数据
        if (this.isPractice) return;

        const trial = this.trials[this.currentTrialIndex];
        const rt = performance.now() - this.startTime;
        
        let choice = '';
        let choseStandard = false;
        
        if (trial.type === 'MLI') {
            choice = (response === 'F') ? 'Left' : 'Right';
            choseStandard = (choice === 'Left' && trial.standardPos === 'left') || 
                            (choice === 'Right' && trial.standardPos === 'right');
        } else {
            choice = (response === 'F') ? 'Top' : 'Bottom';
            choseStandard = (choice === 'Top');
        }

        this.results.push({
            subject: this.subjectId,
            task: trial.type,
            trialIndex: this.currentTrialIndex,
            condition_angle: trial.type === 'MLI' ? trial.angle : trial.bgAngle,
            standard_len: trial.type === 'MLI' ? trial.standardLen : trial.topLen,
            comp_len: trial.type === 'MLI' ? trial.compLen : trial.bottomLen,
            response: choice,
            rt: Math.round(rt),
            chose_standard: choseStandard ? 1 : 0
        });
    }

    nextTrial() {
        this.inputAllowed = false;
        this.ctx.fillStyle = '#ffffff';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        setTimeout(() => {
            this.currentTrialIndex++;
            this.runTrial();
        }, 1000);
    }

    downloadData() {
        if (this.results.length === 0) { alert("无有效实验数据（练习数据不保存）"); return; }
        
        let csvContent = "data:text/csv;charset=utf-8,";
        const headers = Object.keys(this.results[0]).join(",");
        csvContent += headers + "\r\n";
        
        this.results.forEach(row => {
            csvContent += Object.values(row).join(",") + "\r\n";
        });

        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", `experiment_data_${this.subjectId}.csv`);
        document.body.appendChild(link);
        link.click();
    }
}

const experiment = new Experiment();

</script>
</body>
</html>
